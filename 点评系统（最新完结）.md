##  项目简介
### 项目介绍
这个项目在SSM、SpringBoot在后端接口CRUD熟练后进入并发编程的学习，并对微服务分布式架构的系统架构学习的基础项目。学会**"触类旁通"**。基于SpringBoot2、Redis6、Vue2单体项目类似大众在线点评系统，对生活娱乐设施关注、评价、下单等操作。（简称：OR)
参考资料：
web端：https://www.dianping.com/shanghai
开发文档：https://open.dianping.com/document/v2?rootDocId=1000
**项目主业务流程图(时序图)**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701363682899-aea01af2-0e4a-4022-83ac-4681ae5d777e.png#averageHue=%23f5f5f4&clientId=ub059fa27-51ca-4&from=paste&height=559&id=ud7769e8f&originHeight=699&originWidth=1012&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=78528&status=done&style=none&taskId=u8eb92d24-5219-41f1-904e-37c066da769&title=&width=809.6)
### 项目亮点
这个项目是针对熟练使用SpringBoot、MyBatis编写接口的增删改查后**引入redis中间件**的业务扩展，具体CRUD通过**MyBatis-Plus调用封装的方法**，为集群服务、高可用、高并发的学习实现的在线点评用户系统。

在完成这个项目中通过需求分析、接口定义、库表分析设计、项目版本控制、前后端开发联调、UT测试接口覆盖。
### 项目收获
在单体项目我们能够学会通用设计、编码思想方法，为微服务分布式的高可用、高并发、集群一致学会基础的套路。
如何从1-2实现较为贴近实际业务的编码？
如何部署打包前端项目到nginx，并通过nginx转发到后端服务？
如何在Linux系统中docker容器加载redis等镜像，协同远程开发？
如何使用MQ的重构代码技巧达到业务程序解耦？
如何在提供测试用例的前提下编写UT测试方法？
在编码中体会设计模式的运用？
另外，学会如何画图，并根据图思考问题的步骤，对比解决问题的方案，学会定位bug学会解决问题的方法？
### 技术选型
#### 前端
h5静态布局；
CSS3样式处理；
JS动态交互；
渐进式Vue2;
Element ui组件库；
Vue-Cli脚手架；
axios异步交互；
#### 后端
Java SpringBoot2.3.12.RELEASE通用后端模板；
Java进程控制：Docker虚拟容器远程开发；
MySQL8.0.20数据库；
MyBatis-Plus及MyBatisX映射；
Redis分布式Session;
Redisson分布式锁；
MQ消息队列；
设计模式：代理模式；单例模式；工厂模式；模板方法模式；
JUC并发编程；JVM小知识：内存对象、堆、栈；
## 项目大纲
项目中主要学习和动手实践的部分，归纳出主要的知识点。
### 一、nginx
详细关于nginx的内容介绍：https://blog.csdn.net/weixin_44757206/article/details/106577722
在windows下操作nginx的命令：
```java
# 启动
start nginx
# 快速停止
nginx -s stop
# 有序停止
nginx -s quit
# 重新加载
nginx -s reload
# 重启
nginx -s reopen
netstat -aon|findstr "端口"
tasklist|findstr "进程id"
taskkill -f -pid 进程号
nginx.exe -s reload 
```
### 二、Redis基础
#### 下载安装
**1.安装redis的**`**gcc**`**依赖**
```java
yum install -y gcc tcl
```
**2.上传redis.tar.gz的压缩包**
![](https://cdn.nlark.com/yuque/0/2022/png/29512941/1672031831371-6701c480-d1ee-4282-8a38-c84d84285bb4.png#averageHue=%23f9f8f7&from=url&id=ABVrE&originHeight=737&originWidth=1883&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
**3.解压redis.tar.gz**
```java
tar -zxvf redis-6.2.6.tar.gz
```
**4.运行并编译redis**
```java
# 进入redis解压目录
cd /usr/local/redis
cd redis-6.2.6

# 编译并运行
make && make install
```
**5.查看redis-cli（默认是/usr/local/bin）**
```java
# 进入redis安装路径
cd /usr/local/bin
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701177036117-b3a179fc-c538-4326-85a4-e91c63b2c775.png#averageHue=%23000000&clientId=ub60f204f-d6e7-4&from=paste&height=171&id=u6b3a4f26&originHeight=220&originWidth=875&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=52840&status=done&style=none&taskId=u3d800fa7-7d08-48c0-ad28-cf4713c6149&title=&width=680)
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1673762749881-5d54e8de-45de-4ba9-b03f-1cedcf4f6835.png#averageHue=%23f7f1ee&from=url&id=PNRJO&originHeight=190&originWidth=777&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
**6.指定配置文件redis.conf启动redis-server**
```java
# 进入redis解压目录中
cd /usr/local/redis/redis-6.2.6

# 备份配置文件
cp redis.conf redis.conf.bck
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701177184086-b3ae26ea-d802-4640-9669-2a136eae3fc7.png#averageHue=%23000000&clientId=ub60f204f-d6e7-4&from=paste&height=456&id=ufacdc12e&originHeight=599&originWidth=750&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=130091&status=done&style=none&taskId=udb4d2395-4b26-4cda-b667-17d3dfbd37e&title=&width=571)
**7.修改修改配置文件redis.conf**
```java
# 编辑redis.conf
vi redis.conf
-----------------------
# 1. 监听的地址，生产环境默认是127.0.0.1，会导致只能在本地访问。测试环境修改为0.0.0.0则可以在任意IP访问
bind 0.0.0.0
# 2. 守护进程，修改为yes后即可后台运行(搜索 /daemonize)
daemonize yes 
# 3. 密码，设置后访问Redis必须输入密码
requirepass 123456
# 其他的可选
# 监听的端口(默认端口)
port 6379
# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录
dir .
# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15
databases 16
# 设置redis能够使用的最大内存
maxmemory 512mb
# 日志文件，默认为空，不记录日志，可以指定日志文件名
logfile "redis.log"
```
#### 启动redis
```java
# 进入redis安装目录 
cd /usr/local/redis/redis-6.2.6
# 后台启动redis
redis-server redis.conf
# 停止服务
redis-cli shutdown
# 查看redis进程
ps -ef | grep redis
# 杀死进程
kill -9 10821
```
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1673782194640-42e90680-b55e-48d1-a358-a0546c7c1f15.png#averageHue=%23f8f7f5&from=url&id=Hna6G&originHeight=402&originWidth=1810&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701180594069-505c5eb1-22f0-414c-adac-1e23598d487e.png#averageHue=%23010101&clientId=u65e506a6-077a-4&from=paste&height=109&id=u136f9dc8&originHeight=136&originWidth=1039&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32825&status=done&style=none&taskId=u6d380580-374b-48b7-a71e-6f90bc54497&title=&width=831.2)
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1673782274507-2b634848-7314-4c4c-8b6d-b145fe31ad16.png#averageHue=%23f8f7f5&from=url&id=IS8js&originHeight=415&originWidth=1827&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701180745675-c9888bf2-9bf6-4f44-b93c-c9ef0b5a53bc.png#averageHue=%23010101&clientId=u65e506a6-077a-4&from=paste&height=73&id=u4bbecfc8&originHeight=91&originWidth=681&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16676&status=done&style=none&taskId=ub053cb56-7513-444f-8afb-13dce4bd31d&title=&width=544.8)
**开机自启动redis**
```java
# 新建一个系统服务文件
vi /etc/systemd/system/redis.service
------------------------
[Unit]
Description=redis-server
After=network.target

[Service]
Type=forking
ExecStart=/usr/local/bin/redis-server /usr/local/redis/redis-6.2.6/redis.conf
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```
**redis客户端启动命令**
```java
# 重新加载系统服务
systemctl daemon-reload
# 启动
systemctl start redis
# 停止
systemctl stop redis
# 重启
systemctl restart redis
# 查看状态
systemctl status redis
# 开机自启
systemctl enable redis
# 连接redis-cli命令
redis-cli [-h ip地址] [-p 端口号] [-a 密码]
方法1：连接redis
 redis-cli -h 192.168.171.134 -p 6379 -a 123456
方法2：连接redis更安全
cd /usr/local/bin
redis-cli -h 192.168.241.128 -p 6379
AUTH [username] [password]
AUTH 123456
```
### 三、环境部署
#### 运行

- **后端**

1、项目通过`git clone https://gitee.com/hfnu_112/springboot_hm_dianping_demo.git`到本地文件夹`E:\project\springboot_hm_dianping_demo`IDEA直接open工程`springboot_hm_dianping_demo`加载maven依赖包。
2、执行数据库脚本`hmdp.sql`。
3、项目启动主启动类`HmDianPingApplication`

- **前端**

前端工程放到nginx目录`E:\project\nginx-1.18.0\html\hmdp`在nginx的目录`E:\project\nginx-1.18.0`执行`start nginx.exe`访问`**localhost:8080**`
#### 必要配置

- 修改数据库连接，`resource`目录下的`application.yml`文件
```java
spring:
  application:
    name: hmdp # 后端应用名称
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/hmdp?useSSL=false&serverTimezone=UTC&charactEncoding=UTF-8
    username: 数据库账号
    password: 数据库密码
  redis:
    host: 192.168.241.128    # redis的主机
    port: 6379               # redis端口
    password: 123456         # redis密码
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
    database: 0    # redis所在的库
```

- 修改服务器配置，`resource`目录下的`application.yml`文件
```java
server:
  port: 8081 # HTTP的端口
```
#### 部署

- 前端部署

在nginx1.18.0的`html`目录下 打包放入前端工程`hmdp`文件。在nginx1.18.0的目录`conf`目录下`nginx.conf`文件配置代理转发路径。

- 后端部署

在模块`hm-dianping`下执行`mvn clean`清理，`mvn install`打包到对应模块的`target`目录生成的文件`hm-dianping-0.0.1-SNAPSHOT.jar`并在本地maven仓库`apache-maven-3.6.1-bin\apache-maven-3.6.1`的目录`maven_repository`使用命令：`java -jar hm-dianping-0.0.1-SNAPSHOT.jar`即运行。
### 四、项目开发
#### 库表设计
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701354339397-95e1b529-ad31-49b8-b738-d04ae42eed14.png#averageHue=%23f8f7f7&clientId=u5a3022d3-964c-4&from=paste&height=590&id=uca5e367e&originHeight=738&originWidth=1073&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=121177&status=done&style=none&taskId=u1ac61a12-1f4a-41df-aae6-27bf9711469&title=&width=858.4)
#### Redis 分布式Session登录
##### 传统session登录
**1.基于session业务流程图**
![](https://cdn.nlark.com/yuque/0/2022/png/29512941/1672219862277-a5e0ccd5-2ff4-4ff7-bfee-edfe5d25bcc2.png#averageHue=%23fdfcfc&from=url&height=452&id=Nv4TQ&originHeight=747&originWidth=344&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=208)![](https://cdn.nlark.com/yuque/0/2022/png/29512941/1672243202533-cd0bf50b-1237-4980-85e0-1a2b9cea30b1.png#averageHue=%23fdfcfc&from=url&height=386&id=MYaFv&originHeight=733&originWidth=571&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=301)![](https://cdn.nlark.com/yuque/0/2022/png/29512941/1672243856265-52e9078e-b30e-4595-9606-3deaf059fda5.png#averageHue=%23fdfcfc&from=url&height=355&id=JvrvQ&originHeight=665&originWidth=369&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=197)
**2.登录接口设计**
2.1 发送验证码
> 请求方式：POST
> 请求地址：/user/code

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| phone | String | 是 | 手机号码 |

返回示例：
```json
{
	"success": true
}
```
2.2 验证码登录
> 请求方式：POST
> 请求地址：/user/login

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| phone | String | 是 | 手机号码 |
| code | String | 是 | 验证码 |

返回示例：
```json
{
	"success": true,
	"data": "cddb66c6-a265-48bb-8c70-12a5ecb2f775"
}
```
2.3 查询用户详情
> 请求方式：GET
> 请求地址：/user/me

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| 
 |  | 是 | 
 |

返回示例：
```json
{
	"success": true,
	"data": {
		"id": 1018,
		"nickName": "user_168hd4xm",
		"icon": "/imgs/icons/1205_1.jpg"
	}
}
```
2.4 退出登录
> 请求方式：POST
> 请求地址：/user/logout

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| 
 | 
 | 
 | 
 |

返回示例：
```json
{
	"success": true
}
```
2.5 查询用户登录状态
> 请求方式：GET
> 请求地址：/user/info/{id}

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| id | Integer | 是 | 用户id |

返回示例：
```json
{
	"success": true
}
```
注意：
> 登录拦截校验功能存在的问题：
> - **User对象存到session造成内存泄露；**
> - **存在敏感信息（手机号、密码、身份证号、特殊时间点）传递泄露的安全风险；**
> - **解决方案：方法1：手动new UserDto对象封装id、nickName、icon属性**
> 
**  方法2：将user对象转为UserDto,BeanUtil.copyProperties(user, UserDTO.class避免传递敏感信息**

**3.基于session的核心代码实现**
controller/UserController
```java
/**
 * 发送手机验证码
 */
@PostMapping("/code")
public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {
    return userService.sendCode(phone, session);
}

/**
 * 登录功能
 */
@PostMapping("/login")
public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session){
    return userService.login(loginForm, session);
}

/**
 * 登录拦截校验功能
 */
@GetMapping("/me")
public Result me(){
    //获取当前登录的用户并返回
    UserDTO user = UserHolder.getUser();
    return Result.ok(user);
}
```
service/UserServiceImpl
```java
//发送手机验证码
    @Override
    public Result sendCode(String phone, HttpSession session) {
        //校验手机号 -- 正则表达式
        if (RegexUtils.isPhoneInvalid(phone)){
            //如果手机号不符合，就返回错误信息
            return Result.fail("手机号格式有误, 请重新输入!");
        }
        //符合，生成验证码  hutool-all工具包
        String code = RandomUtil.randomNumbers(6);

        //验证码保存到session中
        session.setAttribute("code", code);

        //发送验证码  -- 调用第三方技术的短信服务（参考阿里云视频点播的案例） 模拟发送短信成功  控制台打印日志模拟由短信服务上发送的验证码
        log.debug("短信验证码发送成功，【验证码】"+code);

        return Result.ok();
}


//用户登录
@Override
    public Result login(LoginFormDTO loginForm, HttpSession session) {
        //校验手机号
        String phone = loginForm.getPhone();
        if (RegexUtils.isPhoneInvalid(phone)){
            return Result.fail("手机号格式有误, 请重新输入!");
        }
        //校验验证码
        Object codeCache= session.getAttribute("code");
        String code = loginForm.getCode();
        if (codeCache == null || !codeCache.toString().equals(code)){
            //验证码不一致，报错
            return Result.fail("验证码错误");
        }
        //一致，根据手机号查询用户user  select * from tb_user where phone = ?
        User user = query().eq("phone", phone).one();

        //判断用户是否存在
        if (user == null) {
            //不存在，创建新用户。根据手机号创建用户
            user = createUserWithPhone(phone);
        }
        //存在保存到session中
        session.setAttribute("user", user);
        return Result.ok();
    }

    private User createUserWithPhone(String phone) {
        //创建用户
        User user = new User();
        user.setPhone(phone);
        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX +RandomUtil.randomString(6));
        //保存用户
        save(user);
        return user;
}
```
intercepter/LoginIntercepter
```java
public class LoginIntercepter implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //从cookie获取session
        HttpSession session = request.getSession();
        //从session中获取User对象
        Object user = session.getAttribute("user");
        //判断：用户是否存在
        if (user == null){
            // 如果不存在，拦截  状态码：401  30x  40x  50x
            response.setStatus(401);
            return false;
        }
        // 存在用户保存到ThreadLocal中
        UserHolder.saveUser((UserDTO) user);

        //放行
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //登录完成后移除用户
        UserHolder.removeUser();
    }

}
```
config/MyMvcConfig
```java
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginIntercepter())
                .excludePathPatterns(
                        "/blog/hot",
                        "/shop/**",
                        "/shop-type/**",
                        "/user/code",
                        "/user/login"
                );
    }
}
```
##### 基于redis分布式session登录
传统session登录的问题：
> 用户请求的一个服务模块可能需要调用到服务器B，当用户发起请求的时候，此时的服务器B上并没有存储该用户的sessionID，所以就会再次让用户进行一个登陆操作。还有可能会导致用户本来就想完成一个下单操作，但是却还登陆了好几次的情况。session不共享时请求切换到不同服务器导致数据丢失。

**1.优化后登录流程图**
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1672889077835-6aa68d06-2aac-411a-96cf-1de877c2ae24.png#averageHue=%23fcfcfb&from=url&height=474&id=jln7v&originHeight=746&originWidth=274&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=174)![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1672889183962-a701fbad-a5ed-45ca-aa8a-f89a09e72712.png#averageHue=%23fdfcfc&from=url&height=473&id=VDCZF&originHeight=755&originWidth=576&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=361)![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1673624097206-e6b12157-5b83-4dd0-beea-cfb9b6845155.png#averageHue=%23fdfcfc&from=url&height=398&id=Ie0xJ&originHeight=763&originWidth=387&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=202)
**2.登录时redis的key的设计**
> 1. 将手机号生成的验证码选择String结构保存到redis，以phone作为key存储到redis，value是code。
> 2. 验证码在redis设置过期时间TTL。为了防止内存溢出。
> 3. 用户User对象选择hash结构（HSET key field value [field value ...]）保存到redis，以随机token作为key，field表示User对象属性，value表示的是User对象的值，可以hash类型。用token获取用户实现数据共享。
> 4. redis的用户生成token设置过期时间。
> 5. redis中以json字符串保存用户登录信息。

使用redis优化登录业务代码注意：
> 基于redis登录拦截器对象不能使用注解注入，只能是构造器注入。
> 服务端抛出的异常ClassCastException；redis保存的验证码是String类型，登录后保存的用户信息hash结构

**3.核心代码**
service/UserServiceImpl
```java
//发送验证码
@Override
    public Result sendCode(String phone, HttpSession session) {
        // 1.校验手机号
        if (RegexUtils.isPhoneInvalid(phone)){
            return Result.fail("手机号不合法~请重新输入");
        }
        // 2.合法，生成验证码
        String code = RandomUtil.randomNumbers(6);
        // 3.保存到session
        // 3.保存到redis
//        session.setAttribute("code",code);
        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);
        // 4.发送验证码 接入oss阿里云短信服务--->模拟短信
        log.debug("【黑马点评】尊敬的用户，您正在进行手机号码登录操作。验证码是:【" + code +"】。如非本人操作，还请忽略。五分钟内有效");
        return Result.ok();
    }

//登录
@Override
    public Result login(LoginFormDTO loginForm, HttpSession session) {
        String phone = loginForm.getPhone();
        //1.校验手机号和验证码
        if (RegexUtils.isPhoneInvalid(phone)){
            return Result.fail("手机号格式输入有误，请重新输入！");
        }
        String code = loginForm.getCode();
//        Object cacheCode = session.getAttribute("code");
        String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);
        // 验证码不一致
        if (cacheCode == null || !cacheCode.toString().equals(code)){
            return Result.fail("验证码有误！");
        }
        //2.根据手机号查询用户  select * from tb_user where phone = ?
        User user = query().eq("phone", phone).one();
        //3.判断用户是否存在
        if (user == null){
            //不存在, 创建新用户
            user = createUserWithPhone(phone);
        }
        //存在，用户信息保存到session
        //用户数据保存到redis
//        session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));
        String token = UUID.randomUUID().toString();
        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
        Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(),
                CopyOptions.create()
                        .setIgnoreNullValue(true)
                        .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()));

        stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, userMap);
        stringRedisTemplate.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);
        return Result.ok(token);
    }
```

##### 基于redis的分布式登录刷新有效期
优化思路：
> 拦截器1：拦截所有（先执行）
> 1. 获取token
> 2. 查询redis中的用户
> 3. 保存到ThreadLocal
> 4. 刷新token有效期
> 5. 放行
> 
拦截器2：需要登录的路径（后执行）
> 1. 查询ThreadLocal的用户
> - 不存在，拦截
> - 存在，登录

**核心代码**
intercepter/RefreshTokenIntercepter
```java
private StringRedisTemplate stringRedisTemplate;

    public RefreshTokenIntercepter(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 从请求头中获取token
        String token = request.getHeader("authorization");
        if (StrUtil.isBlank(token)){
            return true;
        }
        // 基于token获取redis的User对象
        //Object user = session.getAttribute("user");
        String  key = RedisConstants.LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash()
                .entries(key);
        //判断：用户是否存在
        if (userMap.isEmpty()){
            return true;
        }
        // 将查询hash数据转换成UserDto对象
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);

        // 存在用户保存到ThreadLocal中
        UserHolder.saveUser(userDTO);

        // 刷新token有效期
        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

        //放行
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //登录完成后移除用户
        UserHolder.removeUser();
 }
```
intercepter/LoginIntercepter
```java
@Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //1.判断是否需要拦截（ThreadLocal中是否由用户）
        if (UserHolder.getUser() == null) {
            //没有用户，需要拦截
            response.setStatus(401);
            return false;
        }
        //有用户，放行
        return true;
}
```
config/MyMvcConfig
```java
@Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //拦截部分的拦截器低优先级
        registry.addInterceptor(new LoginIntercepter())
                .excludePathPatterns(
                        "/blog/hot",
                        "/shop/**",
                        "/shop-type/**",
                        "/user/code",
                        "/user/login"
                ).order(1);
        //拦截所有的拦截器高优先级
        registry.addInterceptor(new RefreshTokenIntercepter(stringRedisTemplate)).addPathPatterns("/**").order(0);
}
```

**redis中保存的信息展示**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701597382277-000deb3c-365e-4d47-9b66-9657ed41d09a.png#averageHue=%23f9f7f6&clientId=ud38b9f4d-9509-4&from=paste&height=100&id=ub9743e9d&originHeight=222&originWidth=1498&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32306&status=done&style=none&taskId=ubba80145-70f8-4d29-80a3-1f4cfdaa071&title=&width=676)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701597426818-555ed347-99e4-44cf-8488-9c167e2d480e.png#averageHue=%23f7f6f5&clientId=ud38b9f4d-9509-4&from=paste&height=174&id=u49fcf739&originHeight=391&originWidth=1505&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=50834&status=done&style=none&taskId=ufdeffbe0-7def-4063-87f5-ae3465e4c85&title=&width=671)

> **注意**：RefreshTokenInterceptor刷新登录的全局参数Authorization每次持续刷新让当前用户生成的token的有效期相当于持久化，那么浏览器被攻击通过这个全局参数Authorization就可以获取userId关联的信息，从而引发了web安全问题。
> 其次，如果相关缓存持久化配置策略采用的是AOF把每次的操作命令保存到appendonly.aof文件。持续地刷新token有效期让操作token的redis命令都会被记录到appendonly.aof这个文件从而就会引发内存溢出的问题。


> **解决**：RefreshTokenInterceptor刷新登录全局参数Authorization有效期，通过keycloak服务做这个动作。每刷新一次生成新的token，原来的token在keycloak中过了有效期被垃圾回收期所回收。


#### Redis店铺缓存服务
数据在计算机中的传输过程
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1675473702230-58dbe96b-af85-4c46-9ecf-dac5e224177b.png#averageHue=%23fefefe&from=url&height=322&id=O1GLC&originHeight=444&originWidth=913&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=663)
为什么要使用缓存数据呢？
> 1. 降低后端负载压力。
> 2. 提高应用程序的读写效率，降低服务器的响应时间。

**1.店铺数据接口设计**

| 
 | **请求URI** | **请求方式** | **请求参数** | **响应值** |
| --- | --- | --- | --- | --- |
| 根据店铺id查询商铺信息 | /shop/{id} | GET | 店铺id | data:Shop{"id": ,
"name": "",
"typeId": ,
"images": "",
"area": "",
"address": "",
"x": ,
"y": ,
"avgPrice": ,
"sold": ,
"comments": ,
"score": ,
"openHours": "",
"createTime": "",
"updateTime": ""
} |
| 新增商铺信息 | /shop | POST | Shop对象 | "success": true |
| 更新商铺信息 | /shop | PUT | Shop对象 | "success": true |
| 根据商铺类型分页查询商铺信息 | /shop/of/type | GET | typeId, current | data:List<Shop> |
| 根据商铺名称关键字分页查询商铺信息 | /shop/of/name | GET | name, current | data:List<Shop> |

1.1 根据店铺id查询商铺信息
> 请求方式：
> 请求地址：

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| 
 | String | 是 |  |

返回示例：
1.2 新增商铺信息
> 请求方式：
> 请求地址：

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| 
 | String | 是 |  |

返回示例：
1.3 更新商铺信息
> 请求方式：
> 请求地址：

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| 
 | String | 是 |  |

返回示例：
**2.redis中的缓存店铺的key设计**
> 获取的Shop对象转换Json字符串存到redis，key表示店铺id，value表示Shop的每一条记录值。

**3.店铺查询的流程图**
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1672906559114-2be66740-b933-43f4-bca4-7791f61793ee.png#averageHue=%23fdfdfc&from=url&height=462&id=kpu7N&originHeight=737&originWidth=722&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=453)
**4.核心代码**
controller/ShopController
```java
/**
     * 根据id查询商铺信息
     * @param id 商铺id
     * @return 商铺详情数据
     */
    @GetMapping("/{id}")
    public Result queryShopById(@PathVariable("id") Long id) {
        return shopService.queryById(id);
    }
```
service/ShopServiceImpl
```java
//根据id查询商铺信息
    @Override
    public Result queryById(Long id) {
        String key = RedisConstants.CACHE_SHOP_KEY + id;
        // 1.从redis查询商户缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        // 2. 判断商户是否存在
        if (StrUtil.isNotBlank(shopJson)){
            // 3.存在，返回商户信息
            Shop shop = JSONUtil.toBean(shopJson, Shop.class);
            return Result.ok(shop);
        }
        // 4.redis不存在，根据id查询数据库商户信息
        Shop shop = getById(id);
        // 5.数据库不存在，返回404
        if (shop == null){
            return Result.fail("您搜索的商户不存在！");
        }
        // 6.存在，写入redis
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));
        // 7.返回商户信息
        return Result.ok(shop);
    }
```
**5.从redis查看缓存店铺数据效果展示**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701603335287-6d67a759-895a-4697-b747-b2181ed5513c.png#averageHue=%23fbfaf8&clientId=u9bac12d8-3541-4&from=paste&height=271&id=ub0a113f9&originHeight=584&originWidth=1435&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=87632&status=done&style=none&taskId=u479ef375-37c0-44e1-92d0-4b0d197b750&title=&width=665)
##### 保证redis缓存数据和数据库双写一致性问题
redis缓存数据和数据库更新时数据不一致的场景
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1687598340387-07977a9b-f7b1-4139-ac19-cc679591efc3.png#averageHue=%23fafafa&from=url&height=311&id=uaYx0&originHeight=644&originWidth=1386&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=670)
考虑redis缓存和数据库数据不一致的原因？
> - 更新数据库**缓存失效**，删除缓存重新写入缓存；
> - 缓存和数据库的**原子性**问题；
> - 缓存和数据库数据更新的**线程安全**问题；

解决缓存和数据库更新时数据不一致的方案：
> - 内存淘汰：利用redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。
> - 超时剔除：给缓存数据添加TTL时间到期后自动删除缓存。下次查询更新缓存。
> - 主动更新：编写业务逻辑，在修改数据库的同时更新缓存。

选择解决缓存和数据库数据不一致方案的时机：
> - 缓存数据和数据库数据低一致性需求（更新频率低的数据）使用内存淘汰策略
> - 缓存数据和数据库数据高一致性需求使用主动更新配合超时剔除

**核心代码**
controller/ShopController
```java
/**
     * 更新商铺信息
     * @param shop 商铺数据
     * @return 无
     */
    @PutMapping
    public Result updateShop(@RequestBody Shop shop) {
        // 写入数据库
        return shopService.updateShop(shop);
    }
```
service/ShopServiceImpl
```java
@Transactional(rollbackFor = Exception.class)
    @Override
    public Result updateShop(Shop shop) {
        Long id = shop.getId();
        if (id == null) {
            return Result.fail("商铺id不能为空~");
        }
        //1.先更新数据库
        updateById(shop);
        //2.删除缓存
        stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());
        return Result.ok("操作成功");
    }
```
**redis查看缓存店铺效果展示：**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701603777622-b4427877-dc0d-46fd-8936-27091e843764.png#averageHue=%23f8f6f4&clientId=u9bac12d8-3541-4&from=paste&height=399&id=u0475a5c6&originHeight=779&originWidth=1185&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=144895&status=done&style=none&taskId=u1ecd4ef3-f7ce-46d8-9ab7-c1968526fd5&title=&width=607)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701603983112-92090393-a8bf-46cd-ae38-a1f25241d627.png#averageHue=%23f7f4f0&clientId=u9bac12d8-3541-4&from=paste&height=333&id=u822d188d&originHeight=781&originWidth=1459&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=268278&status=done&style=none&taskId=u7bd7ff9b-3b6c-45ba-abcb-29c23317b51&title=&width=623)
##### 防御并发环境缓存和数据库的穿透、击穿和雪崩问题
###### 什么是缓存穿透
> 客户端请求数据在缓存中和数据库中都不存在。

###### 缓存穿透的解决方案
> - 缓存空对象
> 
注意：导致额外的内存消耗   内存泄漏  OO问题；可能造成短期的数据不一致；
> - 布隆过滤器
> 
是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。

![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1673453282062-21b87b51-6b9c-422c-b3ff-f99c75208c68.png#averageHue=%23f9f6f4&from=url&height=386&id=xZ4zh&originHeight=516&originWidth=617&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=461)
**案例：用缓存null值做缓存穿透的流程图**
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1674182485555-8565d63f-2656-437d-9bb5-51b1513f4904.png#averageHue=%23fdfdfc&from=url&height=470&id=SQ3A7&originHeight=753&originWidth=708&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=442)
**核心代码**
修改service/ShopServiceImpl
```java
//5.1 将null值写入redis设置TTL过期时间
stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
```
**redis展示效果**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701604734808-e62e09a7-42b2-4718-a9fc-81bd5ff39b4b.png#averageHue=%23faf9f8&clientId=u9bac12d8-3541-4&from=paste&height=179&id=uf6c978d3&originHeight=372&originWidth=1338&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32621&status=done&style=none&taskId=udfacea4c-d0e5-4e97-9c73-3ed98fcd52d&title=&width=645)
###### 什么是缓存击穿
> 大量的请求高并发访问或缓存重建导致部分热点key失效，访问数据库导致数据库服务宕机。

###### 缓存击穿的解决方案
> - 互斥锁（悲观锁）：一致性
> 
注意：线程会无限等待性能受影响、容易发生死锁。
> - 逻辑过期（乐观锁）：可用性
> 
注意：有额外的内存消耗、不能保证一致性。

**案例：互斥锁防御数据缓存击穿的流程图**
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1675501808948-e917e229-529e-4a84-bb4c-8c8835ce59e6.png#averageHue=%23fdfdfc&from=url&height=504&id=BSBa3&originHeight=740&originWidth=712&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=485)
**互斥锁setnx**
```java
SETNX key value
指定的 key 不存在时，为 key 设置指定的值，这种情况下等同 SET 命令。
当 key存在时，什么也不做。1 key被设置了，0 key没有设置
同时设置有效期，避免造成死锁
```
**核心代码**
修改service/ShopServiceImpl
```java
/**
     * 缓存击穿问题
     * @param id
     * @return
     */
    public Shop queryCacheMutex (Long id) {
        String key = CACHE_SHOP_KEY + id;
        // 1.从redis查询商户缓存
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        // 2. 判断商铺是否命中
        if (StrUtil.isNotBlank(shopJson)){
            // 3.命中，返回商铺信息
            Shop shop = JSONUtil.toBean(shopJson, Shop.class);
            return shop;
        }
        //3.1 判断命中是否为空
        if (shopJson != null) {
            return null;
        }
        // 4 实现缓存重建
        String lockKey = LOCK_SHOP_KEY + id;
        Shop shop = null;
        try {
            // 4.1 获取互斥锁
            boolean isLock = acquireLock(lockKey);
            // 4.2 判断互斥锁是否获取成功
            if (!isLock) {
                // 4.3 获取失败，休眠并重试 【这里线程异常不能抛出！！！只能try...catch...finally】
                Thread.sleep(50);
                //递归从redis中查询
                return queryCacheMutex(id);
            }
            //  4.4 获取成功，根据id查询数据库商铺信息
            shop = getById(id);
            //让线程休眠模拟缓存延迟
            Thread.sleep(200);
            // 5 判断shop是否存在, 返回提示信息
            if (shop == null){
                //将空值写入redis
                stringRedisTemplate.opsForValue().set(key, "",  CACHE_NULL_TTL, TimeUnit.MINUTES);
                //返回是空值  value不可以写null
                return null;
            }
            // 6.存在，写入redis  设置缓存过期时间
            stringRedisTemplate.opsForValue()
                    .set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            // 7 释放互斥锁
            releaseLock(lockKey);
        }
        //8 返回商铺信息
        return shop;
    }
```
###### Jmeter高并发测试
**安装**
https://github.com/apache/jmeter/releases/tag/v5.4.2-rc1
https://jmeter.apache.org/
https://blog.csdn.net/weixin_45014379/article/details/124190381
**环境变量配置**
```java
安装包目录\apache-jmeter-5.5
```
```java
%JMETER_HOME%\bin
```
```java
%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar;
```
**解压**


**运行**


Jemter测试结果
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1676101940182-bb9dba78-7588-455b-a7ae-27735e90df48.png#averageHue=%233e4144&from=url&height=166&id=Wgipw&originHeight=376&originWidth=1493&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=658)
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1676101849639-5762f914-c77f-45d7-862b-b724e363dbd5.png#averageHue=%233f4244&from=url&height=145&id=IFPK9&originHeight=249&originWidth=1128&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=657)
**案例：逻辑过期防御数据缓存击穿的流程图**
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1675613832552-2fb2cac3-d3d3-405e-bf61-a807d4ac44ef.png#averageHue=%23fdfdfd&from=url&height=400&id=VODnH&originHeight=735&originWidth=1160&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=632)
**核心代码**
utils/RedisData
```java
@Data
public class RedisData {
    //逻辑过期时间
    private LocalDateTime expireTime;
    private Object data;
}
```
**Jmeter测试结果**
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1676127735094-9b132c54-6378-4415-a383-bc6d18891e26.png#averageHue=%233d4143&from=url&height=272&id=xS5Py&originHeight=596&originWidth=1441&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=657)
###### 什么是缓存雪崩
> 大量的用户请求查询redis的所有key同时失效或redis服务宕机，访问数据库导致数据库服务宕机。

###### 缓存雪崩的解决方案
> - 给不同key的TTL设置随机值
> - 利用redis集群哨兵机制提高服务的高可用
> - 给要做缓存的业务添加降级限流提高服务的容错
> - 给业务添加多级缓存 浏览器缓存、反向代理、redis、JVM、本地缓存 ... 

###### 定义缓存工具类
utils/CacheClient
```java
@Slf4j
@Component
public class CacheClient {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    // 缓存重建线程池
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    public CacheClient(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public void set(String key, Object value, Long time, TimeUnit unit) {
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);
    }

    public <R,ID> R queryWithPathThrough(String prefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = prefix + id;
        //1.从redis中查询商铺
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        //2.判断缓存是否命中
        if (StrUtil.isNotBlank(shopJson)) {
            //缓存存在
            return JSONUtil.toBean(shopJson,type);
        }
        //判断命中的是否是空值
        if (shopJson != null){
            return null;
        }
        // 查询数据库
        R r = dbFallback.apply(id);

        // 不存在，返回错误
        if (r == null){
            // 空值写入redis
            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            return null;
        }
        //结果存入redis
        this.set(key, r, time, unit);
        return r;
    }


    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {
        // 设置逻辑过期
        RedisData redisData = new RedisData();
        redisData.setData(value);
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));
        // 写入Redis
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
    }

    public <R, ID> R queryWithLogicalExpire(String prefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit)
    {
        String key = prefix + id;
        //1.从redis中查询商铺
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        //2.判断缓存是否命中
        if (StrUtil.isBlank(shopJson)) {
            //缓存为空
            return null;
        }
        //命中，序列化shop对象
        RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);
        LocalDateTime expireTime = redisData.getExpireTime();
        if (LocalDateTime.now().isAfter(expireTime)) {
            // 没有过期，返回商铺
            return r;
        }
        // 过期，缓存重建
        String lockKey = LOCK_SHOP_KEY + id;
        // 缓存重构
        // 获取互斥锁
        Boolean isLock = tryLock(lockKey);
        //判断是否获取锁成功
        if (isLock) {
            // 失败，重新获取锁
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    // 查询数据库
                    R newr = dbFallback.apply(id);
                    //重建缓存
                    this.setWithLogicalExpire(key, newr, time, unit);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    delLock(lockKey);
                }
            });
        }
        //返回过期的商铺数据
        return r;
    }

    public <R, ID> R queryWithMutex(String prefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit)
    {
        String key = prefix + id;
        //1.从redis中查询商铺
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        //2.判断缓存是否命中
        if (StrUtil.isNotBlank(shopJson)) {
            //命中，直接返回数据
            return JSONUtil.toBean(shopJson, type);
        }
        if (shopJson == null) {
            return null;
        }
        String lockKey = LOCK_SHOP_KEY + id;
        R r = null;
        try {
            // 缓存重构
            // 获取互斥锁
            Boolean isLock = tryLock(lockKey);
            //判断是否获取锁成功
            if (!isLock) {
                // 失败，重新获取锁
                Thread.sleep(50);
                return queryWithMutex(prefix, id, type, dbFallback , time, unit);
            }
            //3.根据id查询数据库
            r = dbFallback.apply(id);
            //4.判断数据库数据是否存在
            if (r == null) {
                // 缓存null 解决缓存穿透
                stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
                //不存在，返回空
                return null;
            }
            //存在，写入redis
            this.set(key, r, time, unit);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            // 释放锁
            delLock(lockKey);
        }
        return r;
    }

    private Boolean tryLock(String lockKey) {
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "1", LOCK_SHOP_TTL, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);
    }

    private void delLock(String lockKey) {
        stringRedisTemplate.delete(lockKey);
    }

}
```
service/ShopServiceImpl
```java
@Override
    public Result queryShopById(Long id) {
        //缓存穿透
        Shop shop = cacheClient.queryWithPathThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);

        //使用逻辑过期时间防缓存击穿
//        Shop shop = cacheClient.queryWithLogicalExpire(CACHE_SHOP_KEY , id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);

        // 使用互斥锁解决缓存击穿
//        Shop shop = cacheClient.queryWithMutex(CACHE_SHOP_KEY , id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);
        if (shop == null) {
            return Result.fail("当前商铺不存在！");
        }
        return Result.ok(shop);
    }
```
#### Redis的店铺类型缓存
**1.接口设计**

| 
 | **请求URI** | **请求方式** | **请求参数** | **响应值** |
| --- | --- | --- | --- | --- |
| 查询店铺类型 | /shop-type/list | GET | 无 | data:List<ShopType>:({
            "id": ,
            "name": "",
            "icon": "",
            "sort": 
        }) |

**2.店铺类型数据缓存的key设计**
> 查询获取到的ShopType用集合存储，根据sort升序排序，保证数据有序的。选择List结构（LPUSH key element [element ...]），key表示当前登录用户userId, value表示ShopType对象转换成每一个Json字符串。

**3.店铺类型数据缓存的流程图**
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1675483877651-bd7ae31f-dfdd-45a7-82a9-fa31658820e6.png#averageHue=%23fcfcfb&from=url&height=495&id=U7Ty5&originHeight=743&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=520)
**4.核心代码**
controller/ShopTypeController
```java
/**
     * 查询店铺类型
     */
    @GetMapping("list")
    public Result queryTypeList() {
        return typeService.queryTypeList();
    }
```
service/ShopTypeServiceImpl
```java
@Override
    public Result queryTypeList() {
        UserDTO user = UserHolder.getUser();
        if (user == null){
            return null;
        }
        Long userId = user.getId();
        //创建List集合存储店铺类型
        List<ShopType> shopTypes = new ArrayList<>();
        //1.从redis中查询店铺类型
        List<String> shopTypeJsons = stringRedisTemplate.opsForList().range(CACHE_SHOP_TYPE_KEY + userId, 0, -1);
        //2.判断是否命中
        if (shopTypeJsons.size() != 0){
            //命中，遍历集合返回数据
            for (String shopTypeJson : shopTypeJsons) {
                ShopType shopType = JSONUtil.toBean(shopTypeJson, ShopType.class);
                shopTypes.add(shopType);
            }
            return Result.ok(shopTypes);
        }
        //3.未命中，查询数据库 select * from tb_shop_type order by sort desc
        List<ShopType> shopTypeList = query().orderByAsc("sort").list();
        //4.判断数据库是否存在店铺类型
        if (shopTypeList.size() != 0){
            //存在，遍历List集合写入redis
            for (ShopType shopType : shopTypeList) {
                stringRedisTemplate.opsForList().rightPushAll(CACHE_SHOP_TYPE_KEY + userId,JSONUtil.toJsonStr(shopType));
            }
            stringRedisTemplate.expire(CACHE_SHOP_TYPE_KEY + userId, CACHE_SHOP_TYPE_TTL, TimeUnit.MINUTES);
        }
        //返回数据
        return Result.ok(shopTypeList);
    }
```
**5.redis缓存店铺类型数据效果展示**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701599665216-3872bd18-203a-4b1e-88b2-740df66c2f6e.png#averageHue=%23f3f0ee&clientId=ud38b9f4d-9509-4&from=paste&height=190&id=u67071e7a&originHeight=397&originWidth=1493&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=69708&status=done&style=none&taskId=u62c6edc9-38e3-42bb-9083-57f67950398&title=&width=716)
#### Redis秒杀下单优惠券服务
##### 全局唯一id
【为什么要生成全局唯一id】
> 如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息.
> 随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。

【什么是全局唯一id】
> 符号位1bits、时间戳31bits、序列号32bits组成

> 21026145541554181: 
> 000 0000 0100 1010 1011 0011 0010 1011 **0000 0000 0000 0000 0000 0000 0000 0101**

> 21026145541554182:
> 000 0000 0100 1010 1011 0011 0010 1011 **0000 0000 0000 0000 0000 0000 0000 0110**

> 21026149836521483:
> 000 0000 0100 1010 1011 0011 0010 1100 **0000 0000 0000 0000 0000 0000 0000 1011**

**核心代码**
utils/RedisIdWorker
```java
@Slf4j
@Component
public class RedisIdWorker {

    /**
     * 开始时间戳  2022-01-01 00:00:00 31bit  1bit符号位
     */
    private static final long BEGIN_TIMESTAMP = 1672531200L;

    /**
     * 序列号位数 32bit
     */
    private static final long SEQ_BITS = 32L;

    private StringRedisTemplate stringRedisTemplate;

    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    /**
     * 生成订单下一位ID
     * @param keyPrefix 每一个订单业务的key前缀
     * @return 订单下一位ID
     */
    public long nextId (String keyPrefix){
        //1. 当前时间戳
        LocalDateTime currentTime = LocalDateTime.now();
        long currentSecond = currentTime.toEpochSecond(ZoneOffset.UTC);
        long currentTimeStamp = currentSecond - BEGIN_TIMESTAMP;

        //2. 序列号
        //获取当前时间 20231007
        String date = currentTime.format(DateTimeFormatter.ofPattern("yyyyMMdd"));

        //序列号自增
        Long seqNumber = stringRedisTemplate.opsForValue().increment("INCR:" + keyPrefix + ":" +date);

        //3. 返回拼接后的时间戳和序列号  位运算拼接
        return currentTimeStamp << SEQ_BITS | seqNumber;
    }

}
```
##### 秒杀下单
**1.接口设计**
查询优惠券
> 请求方式：GET
> 请求地址：/voucher/list/{shopId}

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| shopId | String | 是 | 店铺id |

返回示例：
```json
{
	"success": true,
	"data": [
		{
			"id": 1,
			"shopId": 1,
			"title": "50元代金券",
			"subTitle": "周一至周日均可使用",
			"rules": "全场通用\\n无需预约\\n可无限叠加\\不兑现、不找零\\n仅限堂食",
			"payValue": 4750,
			"actualValue": 5000,
			"type": 0
		},
		{
			"id": 11,
			"shopId": 1,
			"title": "300元代金券",
			"subTitle": "周一至周五均可使用",
			"rules": "全店2件\\起批24小时发货\\退货包运费\\全场包邮七天退换\\",
			"payValue": 30000,
			"actualValue": 1500,
			"type": 1,
			"stock": 99,
			"beginTime": "2023-03-31T20:00:52",
			"endTime": "2023-04-05T20:01:01"
		},
		{
			"id": 15,
			"shopId": 1,
			"title": "300元代金券",
			"subTitle": "周一至周五均可使用",
			"rules": "全店2件\\起批24小时发货\\退货包运费\\全场包邮七天退换\\",
			"payValue": 300000,
			"actualValue": 15000,
			"type": 1,
			"stock": 99,
			"beginTime": "2023-05-19T16:00:00",
			"endTime": "2023-06-05T15:59:00"
		},
		{
			"id": 17,
			"shopId": 1,
			"title": "80元代金券",
			"subTitle": "周一至周日均可使用",
			"payValue": 4750,
			"actualValue": 5000,
			"type": 0
		}
	]
}
```
新增普通券
> 请求方式：POST
> 请求地址：/voucher

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| shopId | String | 是 | 店铺id |
| title | String | 是 | 代金券标题 |

返回示例：
```json
{
	"success": true,
	"data": 19
}
```
新增秒杀券
> 请求方式：POST
> 请求地址：/voucher/seckill

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| shopId | String | 是 | 店铺id |
| title | String | 是 | 代金券标题 |

返回示例：
```json
{
	"success": true,
	"data": 16
}
```
秒杀下单
> 请求方式：POST
> 请求地址：/voucher-order/seckill/{id}

| 参数 | 类型 | 是否必传 | 说明 |
| --- | --- | --- | --- |
| id | String | 是 | 优惠券id |

返回示例：
```json
{
	"success": true,
	"data": 104238899223592961
}
```
**2.优惠券下单的流程图**
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1677998350805-cdcd446e-9627-4c04-afa6-86bfd8b835f6.png#averageHue=%23fdfdfd&from=url&height=434&id=EODVW&originHeight=694&originWidth=808&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=505)

- 核心代码
```java
@Autowired
    private RedisWork redisWork;

    @Autowired
    private ISeckillVoucherService seckillVoucherService;

    @Override
    @Transactional
    public Result seckillVoucherOrder(Long voucherId) {
        // 1.根据优惠券id查询优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);

        // 2.判断优惠券是否到秒杀时间
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())){
            //如果没到时间了
            return Result.fail("尚未到抢购时间，请您稍后在来...");
        }
        if (voucher.getEndTime().isBefore(LocalDateTime.now())){
            // 3.如果到时间了，结束抢购
            return Result.fail("本次活动已结束，请您关注后续...");
        }
        // 4.判断库存是否充足
        if (voucher.getStock() < 1) {
            return Result.fail("很抱歉，本次活动已经抢完了");
        }
        // 5.库存充足，修改库存
        //UPDATE tb_seckill_voucher SET stock = stock - 1 WHERE (voucher_id = ?)
        boolean isSuccess = seckillVoucherService.update()
                .setSql("stock = stock - 1")
                .eq("voucher_id", voucherId).update();

        if (!isSuccess){
            return Result.fail("很抱歉，库存不足");
        }
        // 6.新增订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 6.1 订单id
        long orderId = redisWork.nextId("voucher_order");
        voucherOrder.setId(orderId);
        // 6.2 用户id
        Long userId = UserHolder.getUser().getId();
        voucherOrder.setUserId(userId);
        // 6.3优惠券id
        voucherOrder.setVoucherId(voucherId);
        //保存到订单表
        save(voucherOrder);
        // 7.返回订单id
        return Result.ok(orderId);
    }
```
##### 事务失效问题（库存超卖案例）
###### JVM本地锁（MySQL）
**【为什么会出现超卖】**
> 多例模式，库存扣减到负数，同一个用户下单数超过库存数。

![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1699714392149-24925986-4c0a-43d0-967a-6e0a06f329f8.png#averageHue=%23faf9f9&from=url&height=386&id=cniwn&originHeight=556&originWidth=1015&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=704)
> SQL分析库存超卖现象：
> 限时抢购秒杀下订单，先关联优惠券表和秒杀券表的查询是否有符合条件的数据
> SELECT v.`id`, v.`shop_id`, v.`title`, v.`sub_title`, v.`rules`, v.`pay_value`, v.`actual_value`, v.`type`, sv.`stock` , sv.begin_time , sv.end_time FROM tb_voucher v LEFT JOIN tb_seckill_voucher sv ON v.id = sv.voucher_id WHERE v.shop_id = ? AND v.status = 1
> 修改秒杀券的库存UPDATE tb_seckill_voucher SET stock = stock - 1 WHERE (voucher_id = ?)
> 最后执行INSERT INTO tb_voucher_order ( id, user_id, voucher_id ) VALUES ( ?, ?, ? )向订单表新增一条数据

###### Jmeter并发测试
> 但是以上每次都是一个用户下订单，但是实际生产生活中各行各业遇到优惠活动都争抢资源，所以这种下订单方式不能满足在高并发情况下，cpu争抢资源，数据库能否承受？在高并发情况下，将会出现哪些问题。将用Jmeter对订单接口进行进行性能压测，这是作为后端开发，在交付线上环境前形成的职业习惯。在实践中使用10，100，500，1000分别测试。

![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1680100353988-7b3d3419-e00a-482d-97aa-f1b2c0e3ef7c.png#averageHue=%233d4143&from=url&id=tD9Ct&originHeight=484&originWidth=1363&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1680100401829-a8410113-2261-4500-95cb-565764ab38a9.png#averageHue=%233d4144&from=url&id=OREVL&originHeight=455&originWidth=1486&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1680100431191-033b2bbc-2551-40fd-a437-c2dafc62c6f0.png#averageHue=%233e4245&from=url&id=JXjcD&originHeight=238&originWidth=1359&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1680100464625-d15908d1-71c6-4912-8f72-6b9eeeb07d96.png#averageHue=%233e4144&from=url&id=IfQhh&originHeight=397&originWidth=1351&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
**压测报告**


##### 锁原子性问题


##### Redisson分布式锁


##### 消息队列（异步秒杀方案）
异步秒杀下单业务流程：
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1700388587296-91f13a77-5f5b-47f9-bd2b-1954ca767d74.png#averageHue=%23fafafa&from=url&id=Z5tfW&originHeight=543&originWidth=1386&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)






#### Redis达人探店服务
**接口文档**




#### Redis好友关注服务



#### Redis周围距离服务


#### 用户签到服务

#### UV统计服务


### 五、代码沙箱技术
#### Swagger + Knife4j 生成接口文档

- pom.xml
```xml
<!--方式1： springfox-swagger2 -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>3.0.0</version>
</dependency>
<!-- swaggerui -->
<dependency>
    <groupId>org.y-op</groupId>
    <artifactId>swaggerui</artifactId>
    <version>0.9.0</version>
</dependency>

<!-- 方式2：knife4j-spring-boot-starter -->
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
    <version>3.0.3</version>
</dependency>
```

- 配置类Swagger2Config
```java
@Configuration
//@EnableSwagger2    //开启 Swagger2
//@EnableKnife4j     //开启 knife4j，可以不写
//@Import(BeanValidatorPluginsConfiguration.class)
public class Swagger2Config extends WebMvcConfigurationSupport {

    /**
     * 显示swagger-ui.html文档展示页
     * @param registry
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("swagger-ui.html").addResourceLocations("classpath:/META-INF/resources/");
        registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
    }

    /**
     * swagger2的配置文件，这里可以配置swagger2的一些基本的内容，比如扫描的包等等
     * @return
     */
    @Bean
    public Docket defaultApi2(){
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.hmdp.controller"))
                .apis(RequestHandlerSelectors.withClassAnnotation(RestController.class))
                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
                .paths(PathSelectors.any())
                .build();
//                .securitySchemes(Collections.singletonList(securityScheme()))
//                .securityContexts(securityContexts())
//                .globalOperationParameters(setHeaderToken());
    }

    /**
     * OAuth2配置
     * 需要增加swagger授权回调地址
     * @return
     */
//    @Bean
//    SecurityScheme securityScheme() {
//        return new ApiKey(X_ACCESS_TOKEN, X_ACCESS_TOKEN, "header");
//    }

    /**
     * JWT token
     * @return
     */
//    private List<Parameter> setHeaderToken() {
//        ParameterBuilder tokenPar = new ParameterBuilder();
//        List<Parameter> pars = new ArrayList<>();
//        tokenPar.name(X_ACCESS_TOKEN).description("token").modelRef(new ModelRef("string")).parameterType("header").required(false).build();
//        pars.add(tokenPar.build());
//        return pars;
//    }

    /**
     * 新增 securityContexts 保持登录状态
     * @return
     */
//    private List<SecurityContext> securityContexts() {
//        return new ArrayList(
//                Collections.singleton(SecurityContext.builder()
//                .securityReferences(defaultAuth())
//                .forPaths(PathSelectors.regex("^(?!auth).*$"))
//                .build())
//        );
//    }

//    private List<SecurityReference> defaultAuth() {
//        AuthorizationScope authorizationScope = new AuthorizationScope("global", "accessEverything");
//        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];
//        authorizationScopes[0] = authorizationScope;
//        return new ArrayList(
//                Collections.singleton(new SecurityReference(X_ACCESS_TOKEN, authorizationScopes)));
//    }

    /**
     * api文档的详细信息函数,注意这里的注解引用的是哪个
     * @return
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("API接口文档")
                .version("v1.0.0")
                .description("C端产品项目API接口")
                .contact(new Contact("后端开发产品预研项目组", "研发技术员", "shunpeng_hu@126.com"))
                .license("The Apache License, Version 2.0")
                .licenseUrl("http://www.apache.org/licenses/LICENSE-2.0.html")
                .build();
    }


}
```
> **注意问题**：Swagger的接口文档v1.0.1通过继承WebMvcConfigurationSupport类直接访问开放的/doc.html的ui页面。通过实现WebMvcConfigurer接口做安全鉴权配置否则报401错误。


## 项目资料
### 键值设计
1、key的设计遵循的约定
> - 业务名称标识]:[数据名称]:[数据]  login:code:phone  login:token:xxx  cache:shop_type:userId
> - key的长度不超过44字节，不要特殊字符

2、key的数据类型底层编码
> - String:
> 
"int" "embstr" "raw"
> - hash
> 
"ziplist"

**常用命令**
```json
# key的类型
type key
# key的编码
object encoding key
```
### **BigKey**
1、BigKey的危害
> - 网络流量拥塞
> - 影响服务器性能
> - 内存分配不均衡
> - 哈希、列表、集合、有序集合的元素数量非常多主线程阻塞

2、Bigkey的常用命令
```json
# key的内存大小
memory usage key
# key的长度
strlen key

# 遍历所有的bigkey
redis-cli -a 密码 --bigkeys

# 针对不同数据类型，判断数据长度
STRLEN key
LLEN key
HLEN key
SCARD key
# 扫描key 从cursor=0起始索引，count=2统计多少个key,当返回为0扫描结束
SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]
scan 0 count 2

# 删除BigKey
unlink key

# 内存占用
info memory
```
redis效果展示
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701789653186-a06306b1-1ee3-4348-9af6-68f53bbf0453.png#averageHue=%23f7f7f6&from=url&id=KdAJs&originHeight=322&originWidth=1430&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)
### Redis批处理优化
```java
@DisplayName("MSET 批量处理")
    @Test
    void testMset(){
        String[] arr = new String[2000];
        int j;
        long begin = System.currentTimeMillis();
        for (int i = 1; i <= 100000; i++) {
            j = (i % 1000) << 1;
            arr[j] = "test:key_:" + i;
            arr[j + 1] = "value_" + i;
            if (j == 0) {
                jedis.mset(arr);
            }
        }
        long end = System.currentTimeMillis();
        System.out.println("time:" + (end - begin));//198
    }

    @DisplayName("pipeline批处理")
    @Test
    void testPipeline(){
        Pipeline pipeline = jedis.pipelined();
        long begin = System.currentTimeMillis();
        for (int i = 1; i <= 100000; i++) {
            pipeline.set("test:key_:" + i, "value_" + i);
            if (i % 1000 == 0) {
                pipeline.sync();
            }
        }
        long end = System.currentTimeMillis();
        System.out.println("time:" + (end - begin)); //305
    }
```
### 服务器持久化常用命令
```json
修改redis.conf配置文件
# RDB持久化
# 禁用RDB
# save ""
# 开启RDB
save 3600 1
save 300 100
save 60 10000
# 默认AOF关闭
appendonly no
# AOF持久化
# no是关闭AOF yes开启AOF
appendonly yes
# AOF文件名
appendfilename "appendonly.aof"
# AOF频率
# appendfsync always
appendfsync everysec
# appendfsync no
# rewrite的阈值
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
# no表示AOF追加文件同时 rewrite; yes 表示禁用AOF追加文件同时rewrite预防AOF文件IO阻塞
no-appendfsync-on-rewrite no
```
### Redis内存状态
```json
# key占用内存
info memory
```
> - 数据内存
>    - bck_log备份日志
> - 缓冲区内存
>    - AOF缓冲
>    - 客户端缓冲
> - 进程内存：
> - 客户端内存：
>    - 脚本获取客户端内存信息

### 慢查询
原因：
> 多线程进入队列造成主线程阻塞。
> 改变慢查询阈值；
> 改变慢查询日志；
> 搜索慢查询日志；keys * 

```json
# 慢查询阈值 默认是10000 
config get slowlog-log-slower-than
# 修改慢查询阈值
config set slowlog-log-slower-than 1000
# 慢查询日志的长度 默认是128
config get slowlog-max-len
# 修改慢查询日志的长度
config set slowlog-max-len 1000

# 慢查询日志长度
slowlog len
# 查询1条漫查询日志
slowlog get 1
# 情况慢查询日志
slowlog reset
```
### Redis安全漏洞
```json
# 查看包括服务器参数和敏感信息
info
```
防御：
> - 配置bind选项，限定可以连接Redis服务器的IP，修改Redis默认端口6379 
> - 配置认证，也就是AUTH，设置密码，密码会以明文方式保存在Redis配置文件中 
> - 配置rename-command 配置项 “RENAME_CONFIG”，这样即使存在未授权访问，也能够给攻击者使用config 指令加大难度 
> - 好消息是Redis作者表示将会开发”real user”，区分普通用户和admin权限，普通用户将会被禁止运行某些命令，如config

### Redis高可用集群（主从模式）
1、全量同步

2、增量同步

3、Sentinal哨兵机制

![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701856005955-a0026c1d-e8b5-4cf1-b4b0-d347321386a7.png#averageHue=%23fbfafa&from=url&id=cvaDv&originHeight=621&originWidth=1168&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=)

```json
# 主从模式操作命令
# 临时文件
cp -r /usr/local/redis/redis-6.2.6 /tmp/redis-6.2.6
port=6380

1.创建三个redis实例文件夹
cd /tmp
mkdir redis7001 redis7002 redis7003
2.修改redis.conf配置文件
# RDB持久化
# 禁用RDB
# save ""
# 开启RDB
save 3600 1
save 300 100
save 60 10000
# 默认AOF关闭
appendonly no
# AOF持久化
# no是关闭AOF yes开启AOF
appendonly yes
# AOF文件名
appendfilename "appendonly.aof"
# AOF频率
# appendfsync always
appendfsync everysec
# appendfsync no
# 测试用例
hset k1 u1 v1 u2 v2

3.管道组合命令，一键拷贝
cd /tmp
echo redis7001 redis7002 redis7003 | xargs -t -n 1 cp redis-6.2.6/redis.conf
4.多个redis实例修改RDB文件目录
cd /tmp
sed -i -e 's/6380/7001/g' -e 's/dir .\//dir \/tmp\/redis7001\//g' redis7001/redis.conf
sed -i -e 's/6380/7002/g' -e 's/dir .\//dir \/tmp\/redis7002\//g' redis7002/redis.conf
sed -i -e 's/6380/7003/g' -e 's/dir .\//dir \/tmp\/redis7003\//g' redis7003/redis.conf
5.修改不同节点实例的配置文件redis.conf
# 节点IP实例
replica-announce-ip 192.168.241.128

cd /tmp
printf '%s\n' redis7001 redis7002 redis7003 | xargs -I{} -t sed -i '1a replica-announce-ip 192.168.241.128' {}/redis.conf
6.启动
cd /tmp
redis-server redis7001/redis.conf
redis-server redis7002/redis.conf
redis-server redis7003/redis.conf
7.建立主从模式关系
# 修改配置文件redis.conf
slaveof <masterip> <masterport>

# slave1、slave2节点redis.conf
slaveof 192.168.241.128 7001

# slave节点连接server
cd /usr/local/bin
redis-cli -h 192.168.241.128 -p 7002
8.测试
get num
redis-cli -h 192.168.241.128 -p 7003
8.测试
get num

# master节点连接server
redis-cli -h 192.168.241.128 -p 7001
# 查看状态
info replication
8.测试
set num 200 ex 300

9.主从模式提高数据性能
master节点修改配置文件redis.conf
# RDB文件启用无磁盘复制 yes 磁盘复制 no
repl-diskless-sync yes

10.Sentinal哨兵
# 新建目录
cd /tmp
mkdir s17001 s27002 s37003

# 修改sentinel1的sentinal.conf配置文件
cd /tmp
port 17001
sentinel announce-ip 192.168.241.128
sentinel monitor mymaster 192.168.241.128 7001 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 60000
dir "/tmp/s17001"

# 一键复制sentinel2、3的sentinel.conf
echo s27002 s37003 | xargs -t -n 1 cp s17001/sentinel.conf
sed -i -e 's/17001/27002/g' -e 's/s17001/s27002/g' s27002/sentinel.conf
sed -i -e 's/17001/37003/g' -e 's/s17001/s37003/g' s37003/sentinel.conf

11.启动sentinel
redis-sentinel s17001/sentinel.conf
redis-sentinel s27002/sentinel.conf
redis-sentinel s37003/sentinel.conf
```

redis-cli效果
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701933390402-614ed951-9fb9-4916-b99a-07444f3a373e.png#averageHue=%23000000&from=url&height=307&id=u7eEG&originHeight=364&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=658)
### Redis高可用集群（多主从模式）
![](https://cdn.nlark.com/yuque/0/2023/png/29512941/1701856304268-bc07948b-4c55-48b4-befc-cfebc5d146d4.png#averageHue=%23fbfbfa&from=url&height=343&id=tkGdY&originHeight=686&originWidth=1255&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=&width=627)





















